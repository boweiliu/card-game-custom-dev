import { TransportId } from '@/shared/types/id-prefixes';
import { MessageID, PendingMessageID } from '@/shared/types/responses';

type BaseT = {
  entityId?: string | number;
  transportId: string | number;
}
/**
 * Transitions allowed:
 * - Nothing -> Synced (if we get a protocard from the server)
 * - Nothing -> Creating (if we create a protocard)
 * - Creating -> Synced (after server confirmed)
 * - Synced -> Updating
 * - Updating -> Synced
 * - Synced -> Deleting
 * - Deleting -> None
 * - Anything -> Error
 *
 * Distinguished using "status" field
 * T should be an API transport type, e.g. ProtocardTransport
 * 
 * We store this data because it's relevant to frontend behavior - we may need to show
 * something like "unsaved progress" states, for instance
 */
export type SyncableState<T extends BaseT> =
  | SyncedState<T>
  | CreatingState<T>
  | UpdatingState<T>
  | DeletingState<T>
  | ErrorState<T>;
  // maybe also: upserting state? really for FE, we only care about synced vs not.
  // but in the not-synced state, internally in the data repo we should care about superceding 
  // old messages, out of order, idempotency etc.

export interface BaseState<T extends BaseT> {
  entityId?: T['entityId'];
  transportId: T['transportId'];
  curr: T;
  status: 'synced' | 'creating' | 'updating' | 'deleting' | 'error';
}

// EntityId -> corresponds with the database id. Guaranteed to be unique and managed by the DB.
// TransportId -> is a value generated by the frontend to identify a card that may or may not be synced up yet.
export interface SyncedState<T extends BaseT> extends BaseState<T> {
  status: 'synced';
  lastSynced: MessageID;
}

export interface CreatingState<T extends BaseT> extends BaseState<T> {
  status: 'creating';
  syncingWith: PendingMessageID;
  supercedes: Array<PendingMessageID>;
}

export interface UpdatingState<T extends BaseT> extends BaseState<T> {
  status: 'updating';
  lastSynced: MessageID;
  syncingWith: PendingMessageID;
}

export interface DeletingState<T extends BaseT> extends BaseState<T> {
  status: 'deleting';
  lastSynced: MessageID;
  syncingWith: PendingMessageID;
}

export interface ErrorState<T extends BaseT> extends BaseState<T> {
  status: 'error';
  error: {
    message: string;
  };
}
